import numpy as np
from scipy.special import huber
from sklearn.linear_model import HuberRegressor


# TODO Взвешенное среднее через scipy.special.huber
#  * В этом случае используется функция Хьюбера, которая напрямую вычисляет потери (loss) и преобразует
#    их в веса для каждого значения в выборке. Эти веса затем используются для вычисления взвешенного среднего.
#  * При этом мы ручную вычисляем веса для каждой точки на основе их отклонения от медианы, и это позволяет более гибко
#    контролировать влияние выбросов.


# Данные
X = np.array([10, 12, 13, 15, 20, 1000, 2000])
y = np.array([10, 12, 13, 15, 20, 1000, 2000])

# Вычисляем IQR для определения выбросов
q1, q3 = np.percentile(y, [25, 75])
iqr = q3 - q1
delta = 1.5 * iqr  # Порог отсечения

# Применяем Huber loss (она даёт усечённые потери)
weights = huber(delta, y - np.median(y))

# Переводим потери в веса
weights = 1 / (1 + weights)

print("Веса для каждого значения:", weights)
print("Взвешенное среднее:", np.average(y, weights=weights))



# TODO Взвешенное среднее через HuberRegressor
#  * В этом коде используется модель регрессии Huber из sklearn, которая находит коэффициенты (параметры) модели,
#    минимизируя функцию потерь Хьюбера.
#  * Здесь модель обучается на данных и затем предсказывает значения для каждого наблюдения.
#    Мы вычисляем среднее предсказанных значений, что и дает взвешенное среднее.

X1 = np.array([10, 12, 13, 15, 20, 1000, 2000]).reshape(-1, 1)
y = np.array([10, 12, 13, 15, 20, 1000, 2000])

huber = HuberRegressor()
huber.fit(X1, y)

# Получаем устойчивое среднее
weighted_mean = huber.predict(X1).mean()
print(f"Взвешенное среднее (по Хьюберу): {weighted_mean:.2f}")
