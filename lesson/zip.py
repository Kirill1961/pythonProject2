""" Функция zip() принимает итерируемый объект или объекты,
например, список, кортеж, множество или словарь
в качестве аргумента. Затем она генерирует список кортежей,
которые содержат элементы из каждого объекта,
переданного в функцию.
zip объединяет элементы в кортежи, первые вторые и тд элементы 1го списка
с первым вторым элементом второго, третьего и тд
если длина последовательностей разная, то zip остановится на короткой."""
from sys import exc_info
exc_info
a = [1,5,6,9,12]
b = [5,7,2]
d = 'Kirill'
z_ip = zip(a,b,d)
# print(z_ip)
for i in z_ip:
    print(i)

a = [1,5,6,9,12]
b = [5,7,2,4]
d = 'Kirill'
z_ip = zip(a,b,d)
# print(z_ip)
for z1,z2,z3 in z_ip:
    print(z1,z2,z3)

a = [1,5,6,9,12]
b = [5,7,2,4]
d = 'Kirill'
z1,z2,z3,z4 = zip(a,b,d)
print(z1,z2,z3,z4 )
# print(z_ip)
# for z1,z2,z3 in z_ip:
#     print(z1,z2,z3)

a = [0,1,2,1]
b = [1,2,1,0]
c = zip(a,b)
for i in c:
    print(sum(i))

""" получить попарно отдельно ключи из двух и более словарей"""
d_ic = {'K':1, 'i':2, 'r':3}
d_icc = {'r':6, 'l':8, 's':4}

d_c = zip(d_ic,d_icc)
# print(k1,k2,k3)
# for d_i in d_c:
#     print(d_i)
for k1,k2 in d_c:
    print(list(k1),list(k2))


# Поэлементное сложение 2х списков
u=[20,30,50]
i = [1,2,100]
print([x for x in map(sum, zip(i, u)) ], " Поэлементное сложение 2х списков 1й вариант", "\n")
print([sum(x) for x in zip(i, u) ], " Поэлементное сложение 2х списков 2й вариант", "\n")


# Сложение значений внутри списков 3-х и более
y = [[11, 200], [35, 441], [800, 1000]]
print([sum(i[0]) for i in zip(y)], " Сложение значений внутри списков 3-х и болеее", "\n")

# Поэлементное сложение 3х и более списков
print([sum(j) for j in [[i[0] for i in y  ], [i[1] for i in y ]]], " Поэлементное сложение 3х и более списков", "\n")

# Поэлементное умножение 2х списков
print([a*b for a,b in zip(i, u)], " Поэлементное умножение 2х списков")


# ZIP и *ZIP запаковка и распаковка
a, b= [1,2], [3,4]
s = [(2, 22), (8, 88), (9, 99)]
print(zip(a, b), " вывод запакованных элементов с zip без итерации, это адрес ячейки", "\n")
print(list(zip(a, b)), " вывод запакованных элементов с zip через list", "\n")
print(tuple(zip(a, b)), " вывод запакованных элементов с zip через t u p l e ", "\n")

a_b = zip(a, b) # для обратной перестановки items zip размещаем в переменную, те список мы можем прокрутить обратно

print(list(zip(*a_b)),  " вывод распакованных обратно переставленных элементов  с zip через list >> *a_b", "\n")
print(tuple(zip(a, b)),  " вывод распакованных обратно переставленных элементов  с zip через t u p l e >>", "\n")
print(*zip(a, b), " обратная распаковка из списка элементов через *zip", "\n")
print(list(zip(*s)), " вывод запакованных элементов из *s с zip через list", "\n")
print((*zip(s), " вывод распакованных элементов из *s с zip через list", "\n"))

# zip с LIST  разной длинны
b = [[10], [20]]
a = [[1], [2], [3]]
print([[i * j for i, j in zip(a[k], b[k])] for k, _ in enumerate(b)], " zip с LIST  разной длинны", "\n")

# zip с LIST разной длинны + заполнение пустых мест

list1 = [1, 2, 3]
list2 = [1, 2, 3, 4]
list3 = [1, 2, 3, 4, 5]
from itertools import zip_longest
for a, b, c in zip_longest(list1, list2, list3, fillvalue="&"):
  print(a, b, c,)
print("LIST разной длинны + заполнение пустых мест любым символом ", "\n")


# TODO zip - возвращает Итератор, это свойства можно использовать
#  * Итераторы можно Исчерпать,
#  * List(z) - zip object преобразуется в список
#  * после полного прохода по zip он не может быть использован повторно без явного перезапуска.

l1 = (10, 20, 30)
l2 = (1, 2, 3)
z = zip(l1, l2)

print('Ячейка zip : \n', z)

iter_zip = [i for i in z]

print('Итератор zip Полный : \n', iter_zip)

iter_zip = list(z)

print('Итератор zip Пустой после обёртки в List : \n', iter_zip)